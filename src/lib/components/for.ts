import { BaseComponent } from './base-component';
import { config } from '../config';
import { evaluateExpression } from '../utils';
import { ScopeComponent } from './scope';
import { forDebugger } from '../utils/for-debugger';

export class ForComponent extends BaseComponent {
  private eachValue: string = '';
  private asValue: string = '';
  private template: HTMLTemplateElement | null = null;
  private hasInitialized: boolean = false;
  private renderedScopes: ScopeComponent[] = [];
  private previousArrayValue: any[] = [];

  constructor() {
    super();
  }

  connectedCallback() {
    this.initializeAttributes();
    this.initializeTemplate();
    this.listenToUpdates();
    this.render();

    // Only log initial state and check for issues
    forDebugger.logForState(this);
    forDebugger.checkForIssues(this);
  }

  disconnectedCallback() {
    // Only log cleanup if there are scopes to clean
    if (this.renderedScopes.length > 0) {
      forDebugger.logScopeCleanup(this.renderedScopes);
    }

    // Cleanup rendered scopes
    this.cleanupRenderedScopes();

    // Call parent cleanup
    super.disconnectedCallback();
  }

  private initializeAttributes() {
    try {
      this.eachValue = this.getRequiredAttribute('each');
      this.asValue = this.getRequiredAttribute('as');
    } catch (error) {
      console.error('ForComponent initialization error:', error);
    }
  }

  private initializeTemplate() {
    if (this.hasInitialized) return;

    // Find the default template (template without id)
    this.template = this.querySelector(
      'template:not([id])'
    ) as HTMLTemplateElement;

    if (!this.template) {
      console.error('ForComponent: No default template found');
      return;
    }

    // Clear existing content
    this.innerHTML = '';

    this.hasInitialized = true;
  }

  private listenToUpdates() {
    this.setupAttributeObserver('each', () => {
      this.eachValue = this.getAttribute('each') || '';
      this.render();
    });

    this.setupAttributeObserver('as', () => {
      this.asValue = this.getAttribute('as') || '';
      this.render();
    });

    this.subscribeToSignalDependencies(this.eachValue, () => {
      this.render();
    });
  }

  private render() {
    if (!this.hasInitialized) {
      this.initializeTemplate();
    }

    if (!this.eachValue || !this.asValue) {
      return;
    }

    const context = this.getSafeContext();
    const arrayValue = evaluateExpression(this.eachValue, context);

    if (!arrayValue) {
      console.error(
        `ForComponent: Could not evaluate expression '${this.eachValue}'`
      );
      return;
    }

    if (!Array.isArray(arrayValue)) {
      console.error(`ForComponent: Signal value must be an array`);
      return;
    }

    // Only log array changes if the length actually changed
    const oldLength = this.previousArrayValue?.length || 0;
    const newLength = arrayValue?.length || 0;

    if (oldLength !== newLength) {
      forDebugger.logArrayChange(this.previousArrayValue, arrayValue);
      forDebugger.logRenderCycle(this, arrayValue);
    }

    // Cleanup previous rendered scopes
    this.cleanupRenderedScopes();

    this.innerHTML = '';

    arrayValue.forEach((item, index) => {
      const clone = this.template?.content.cloneNode(true);
      if (!clone) return;

      // Create r-scope wrapper
      const scopeElement = document.createElement(
        config.components.scope
      ) as ScopeComponent;

      // Mark this scope as generated by for component
      scopeElement.markAsForGenerated();

      scopeElement.setContext({
        ...(context.$state as Record<string, unknown>),
        [this.asValue]: item,
        $index: index,
        $item: item,
        $length: arrayValue.length,
      });

      // Only log scope creation for first few items to avoid spam
      if (index < 3) {
        forDebugger.logScopeCreation(scopeElement, item, index);
      }

      // Move the cloned content into the scope
      const fragment = document.createDocumentFragment();
      while (clone.firstChild) {
        fragment.appendChild(clone.firstChild);
      }
      scopeElement.appendChild(fragment);

      this.appendChild(scopeElement);
      this.renderedScopes.push(scopeElement);

      // Only log scope state for first scope to avoid spam
      if (index === 0) {
        forDebugger.logScopeState(scopeElement);
        forDebugger.monitorSignalSubscriptions(scopeElement);
      }
    });

    // Update previous array value
    this.previousArrayValue = [...arrayValue];
  }

  /**
   * Cleanup all rendered scope components
   */
  private cleanupRenderedScopes() {
    this.renderedScopes.forEach(scope => {
      if (scope && scope.parentNode) {
        scope.parentNode.removeChild(scope);
      }
    });
    this.renderedScopes = [];
  }
}

// Register the custom element
customElements.define(config.components.for, ForComponent);

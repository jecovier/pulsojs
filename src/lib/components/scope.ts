import { config } from '../config';
import { Parser } from '../parser';
import { Signal } from '../signals';
import { createSafeContext, parseStringToObject } from '../utils';
import { BaseComponent } from './base-component';

export enum Type {
  STRING = 'string',
  NUMBER = 'number',
  BOOLEAN = 'boolean',
  OBJECT = 'object',
  DATE = 'date',
  ARRAY = 'array',
}

type Signals = Record<string, Signal<unknown>>;

export class ScopeComponent extends BaseComponent {
  private context: Signals = {};
  private parser: Parser | null = null;
  private isDisconnected: boolean = false;

  connectedCallback() {
    this.isDisconnected = false;
    const state = this.getAttribute('state') || '{}';
    const parsedState = this.stringToObject(state);
    this.setContext(parsedState);

    this.parser = new Parser(this);
    const context = createSafeContext(this.context);
    this.parser.replaceEventsWithReactiveListeners(context);
  }

  disconnectedCallback() {
    this.isDisconnected = true;

    // Cleanup parser event listeners
    if (this.parser) {
      this.parser.cleanupEventListeners();
      this.parser = null;
    }

    // Only cleanup signals if this is the root scope (not a for-generated scope)
    if (!this.hasAttribute('data-for-generated')) {
      this.cleanupSignals();
    }

    // Call parent cleanup
    super.disconnectedCallback();
  }

  private stringToObject(state: string): Record<string, unknown> {
    try {
      return parseStringToObject(state || '{}');
    } catch (error) {
      console.error(
        'ScopeComponent: state attribute is not a valid JSON',
        error
      );
      return {};
    }
  }

  public getSignal(name: string): Signal<unknown> {
    return this.context[name];
  }

  public getSignals(): Signals {
    return this.context;
  }

  public setContext(context: Record<string, unknown>) {
    // Don't cleanup signals when setting context for for-generated scopes
    if (!this.hasAttribute('data-for-generated')) {
      this.cleanupSignals();
    }

    for (const key in context) {
      const value = context[key];

      if (value instanceof Signal) {
        this.context[key] = value;
        continue;
      }

      // Only create new signals if this scope is not disconnected
      if (!this.isDisconnected) {
        this.context[key] = new Signal(value);
      }
    }
  }

  /**
   * Cleanup all signals to prevent memory leaks
   * Only call this when the scope is actually being destroyed
   */
  private cleanupSignals() {
    // Clear all signal subscribers
    Object.values(this.context).forEach(signal => {
      if (signal instanceof Signal) {
        // Clear all subscribers for this signal
        signal['_subscribers'].clear();
      }
    });

    this.context = {};
  }

  /**
   * Mark this scope as generated by a for component
   */
  public markAsForGenerated() {
    this.setAttribute('data-for-generated', 'true');
  }
}

// Define using the component name from config
customElements.define(config.components.scope, ScopeComponent);
